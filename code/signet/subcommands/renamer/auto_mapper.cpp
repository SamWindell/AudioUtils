#include "auto_mapper.h"

#include <regex>

#include "doctest.hpp"

void AutoMapper::CreateCLI(CLI::App &renamer) {
    auto auto_map = renamer.add_subcommand(
        "auto-map",
        R"^^(Samplers can often read the root, low and high MIDI note numbers from within a filename. This command makes inserting the low and high keys into the filename simple.

    First you specify a regex pattern that captures a number representing the MIDI root note from the input filenames. This tool collects all of the root notes found in each folder, and works out reasonable values for what the low and high MIDI notes should be.

    You control the format of the renaming by specifing a pattern containing substitution variables for <lo>, <root> and <high>. These variables are replaced by the MIDI note numbers in the range 0 to 127.)^^");

    auto_map
        ->add_option("auto-map-filename-pattern", m_automap_pattern,
                     "The ECMAScript-style regex the should match against filename (excluding extension). "
                     "This regex should contain a capture group to represent the root note of the sample.")
        ->required();

    auto_map->add_option("root-note-regex-group", m_root_note_regex_group,
                         "The group number that represents the MIDI root note number. Remember regex group 0 "
                         "is always the full match.");

    auto_map
        ->add_option(
            "auto-map-renamed-filename", m_automap_out,
            "The name of the output file (excluding extension). This should contain substitution variables "
            "<lo>, <root> and <hi> which will be replaced by the low MIDI note number, the root MIDI note "
            "number and the high MIDI note number. The low and high numbers are generated by the auto-mapper "
            "so that all samples in each folder will fill out the entire range 0-127. Matching groups from "
            "the regex can also be substituted into this new name. To do this, add the regex group index in "
            "the angle-brackets (such as <1>).")
        ->required();
}

fs::path GetParent(const fs::path &path) {
    if (path.has_parent_path()) return path.parent_path();
    return ".";
}

void AutoMapper::AddToFolderMap(const fs::path &path) {
    REQUIRE(m_automap_pattern);
    const std::string filename = GetJustFilenameWithNoExtension(path);
    std::smatch pieces_match;
    std::regex r {*m_automap_pattern};
    if (std::regex_match(filename, pieces_match, r)) {
        if (m_root_note_regex_group >= pieces_match.size()) {
            ErrorWithNewLine("AutoMapper: the regex pattern does not contain contain the group given ",
                             *m_automap_pattern);
            return;
        }

        int root_note {};
        try {
            root_note = std::stoi(pieces_match[m_root_note_regex_group]);
        } catch (...) {
            ErrorWithNewLine("AutoMapper: the given regex group does not contain an integer to represent the "
                             "MIDI root note: ",
                             pieces_match[m_root_note_regex_group]);
        }

        if (root_note < 0 || root_note > 127) {
            WarningWithNewLine("AutoMapper: root note of file ", filename,
                               " is not in the range 0-127 so cannot be processed");
        } else {
            MessageWithNewLine("AutoMapper", "automap found root note ", root_note, " in filename ", path);
            const auto parent = GetParent(path);
            m_folder_map[parent].AddFile(path, root_note, pieces_match);
        }
    }
}

void AutoMapper::ConstructAllAutomappings() {
    for (auto &[path, folder] : m_folder_map) {
        folder.Automap();
    }
}

void AutoMapper::InitialiseProcessing(const tcb::span<EditTrackedAudioFile> files) {
    if (m_automap_pattern) {
        for (auto &f : files) {
            AddToFolderMap(f.GetPath());
        }
        ConstructAllAutomappings();
    }
}

bool AutoMapper::Rename(const EditTrackedAudioFile &f, std::string &filename) {
    if (m_automap_pattern) {
        auto &folder = m_folder_map[GetParent(f.GetPath())];
        if (const auto file = folder.GetFile(f.GetPath())) {
            auto new_name = *m_automap_out;
            Replace(new_name, "<lo>", std::to_string(file->low));
            Replace(new_name, "<hi>", std::to_string(file->high));
            Replace(new_name, "<root>", std::to_string(file->root));
            for (usize i = 0; i < file->regex_groups.size(); ++i) {
                Replace(new_name, PutNumberInAngleBracket(i), file->regex_groups[i]);
            }
            filename = new_name;
            return true;
        }
    }
    return false;
}
